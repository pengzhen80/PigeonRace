<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.5.0/Chart.js"></script>
  <!-- Include 2d map tools -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"
    integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A=="
    crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"
    integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA=="
    crossorigin=""></script>
  <script src='https://unpkg.com/@turf/turf@6/turf.min.js'></script>
  <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
  <style>
    .anybutton {
      bottom: 5%;
      left: 45%;
      /* width:100px;
        height:40px; */
      position: relative;
      z-index: 2;
      /* background: orange;  */
    }
  </style>
</head>

<body>
  <div id="Map_showPaths"></div>
  <div id="Map_showPaths_routeSimilarity"></div>
  <div id="div_smallMap_routeSimilarity_threeroutes"></div>
  <dialog id="dialog_routeEfficiency">
    <form method="dialog">
        <p style="font-size:30px"><label>路徑效率:</label>
        </p>
        <p><label>“路徑效率”是量化鴿子導航能力的一個方式。通過量化鴿子導航能力，能夠追蹤鴿子導航能力的水平和變化，並進行針對性訓練。</label>
        </p>
        <p><label>目前，鴿鐘的做法：只能提供直線分速（直線距離/時間）作爲成績判斷的標準。但是這項數據如果要用來呈現訓練以及比賽歷程，甚至要進行科學化的訓練分析來提升飛行效率，是不夠的。</label>
        </p>
        <p><label>爲了進行科學量化分析，衡量訓練是否有效，參考了多篇論文，引用論文中判斷訓練模型是否有效所採用的路徑效率，來進行分析跟參考：</label>
        </p>
        <p><label>量化導航能力的方式是：比較飛行的路經的效率。把導航能力量化為，“路徑效率”：</label>
        </p>
        <p style="font-size:24px;font-weight:bold"><label>公式：路徑效率 = 直線距離 / 飛行距離。</label>
        </p>
        <p><label>驗證：比賽成績 = 分速 = 直線距離/實際飛行時間 = （實際飛行距離*路徑效率）/實際飛行時間=（實際飛行距離/實際飛行時間）*路徑效率=實際飛行分速*路徑效率。。</label>
        </p>
        <div>
            <button id="confirmBtn_dialog_routeEfficiency" value="default" style="font-size:22px" class="anybutton"">確認</button>
        </div>
    </form>
  </dialog>
  <dialog id="dialog_routeEfficiency_realtime">
    <form method="dialog">
        <p style="font-size:30px"><label>即時路徑偏移量:</label>
        </p>
        <p style="font-size:24px;font-weight:bold"><label>公式：偏離距離=D點到直線</label>
        </p>
        <p><label>用途：量化當前點的偏離直線的情況，偏離的越多，說明當前的路徑準確度越低；</label>
        </p>
        <div>
            <button id="confirmBtn_dialog_routeEfficiency_realtime" value="default" style="font-size:22px" class="anybutton"">確認</button>
        </div>
    </form>
  </dialog>
  <dialog id="dialog_altitudeFromEarth">
    <form method="dialog">
        <p style="font-size:30px"><label>離地高度:</label>
        <p style="font-size:24px;font-weight:bold"><label>公式：離地高度 = 海拔 - 地面海拔；</label>
        </p>
        <div>
            <button id="confirmBtn_dialog_routeEfficiency_realtime" value="default" style="font-size:22px" class="anybutton"">確認</button>
        </div>
    </form>
  </dialog>
  <dialog id="dialog_elevationZoneBar">
    <form method="dialog">
        <p style="font-size:30px"><label>quatile做法:</label>
        <p style="font-size:24px"><label>按照從小到大的方式排列成有序的list，然後25%是指位置在25%的數值，50%就是指中位數，75%是位置在75%的值；</label>
        </p>
        <div>
            <button id="confirmBtn_dialog_routeEfficiency_realtime" value="default" style="font-size:22px" class="anybutton"">確認</button>
        </div>
    </form>
  </dialog>
  <dialog id="dialog_realTimeDistance">
    <form method="dialog">
        <p style="font-size:30px"><label>即時距離:</label>
        <p><label>論文中用這個公式來判斷鴿子是否是pair飛行的，可以作為pair飛行的驗證工具；</label>
        </p>
        <p style="font-size:24px;font-weight:bold"><label>公式：即時距離 = D點到點的距離（timestamp）；</label>
        </p>
        <div>
            <button id="confirmBtn_dialog_routeEfficiency_realtime" value="default" style="font-size:22px" class="anybutton"">確認</button>
        </div>
    </form>
  </dialog>
  <dialog id="dialog_routeSimilarity">
    <form method="dialog">
        <p style="font-size:30px"><label>路徑相似度:</label>
        <p><label>論文中計算所有點到參考路線的距離，計算平均距離，平均距離越小，相似度越高；</label>
        </p>
        <p><label>用法：輔佐路徑效率，判斷鴿子是否對熟悉了某個定點飛行的路線；</label>
        </p>
        <p style="font-size:24px;font-weight:bold"><label>公式：相似度 = {D點到參考路徑}；</label>
        </p>
        <div>
            <button id="confirmBtn_dialog_routeEfficiency_realtime" value="default" style="font-size:22px" class="anybutton"">確認</button>
        </div>
    </form>
  </dialog>
  <dialog id="dialog_leaderOfGroup">
    <form method="dialog">
        <p style="font-size:30px"><label>羣體飛行的領航者:</label>
        <p><label>不論是pair飛行，還是group飛行，我們都希望能夠找到誰是飛行的leader。</label>
        </p>
        <p><label>引用論文中的理論：判斷誰的位置更靠前，來判斷誰是leader。</label>
        </p>
        <p><label>使用從“出發點”到“當前點”的“投影距離”（投影到起始點和終點的直線），來判斷位置，投影距離越大位置越更靠前。</label>
        </p>
        <p style="font-size:24px;font-weight:bold"><label>公式：D投影距離 = 開方（平方（D起點到當前點）-平方（D當前點到直線））</label>
        </p>
        <div>
            <button id="confirmBtn_dialog_routeEfficiency_realtime" value="default" style="font-size:22px" class="anybutton"">確認</button>
        </div>
    </form>
  </dialog>
  <script>
    let routeIds = '{{ routeIds|safe }}';
    let routeId_list = routeIds.split(',');
    console.log(routeId_list);

    request_askRoutesData()
    function request_askRoutesData() {
      function reqListener() {
        // console.log(typeof (this.responseText), typeof (this.response));
        // console.log(this.responseText)

        var response = JSON.parse(this.responseText);
        console.log(Object.values(response));
        show_figures(Object.values(response));

        // var pathName = decodeURI(response['pathname']);
        // var polygon = response['polygon'];
      }

      var oReq = new XMLHttpRequest();
      oReq.addEventListener("load", reqListener);
      oReq.open("post", 'figures/askTracksData');
      oReq.setRequestHeader("X-CSRFToken", '{{ csrf_token|safe }}');
      // oReq.setRequestHeader("Content-Type", "text/plain;charset=UTF-8");   
      oReq.send(routeId_list.toString());
    }

    function show_figures(test_demo_data)
    {
        ///set source data
        const demo_singleRoute = test_demo_data[0];
        console.log(demo_singleRoute.length);
        ///draw path in map
        let div_smallMap_head = document.getElementById('Map_showPaths');
        div_smallMap_head.setAttribute('style', 'width:40%;height:40%;');
        // div_smallMap.setAttribute('style', 'width:800px;height:400px;');
        div_smallMap_head.style.left = "50%";
        div_smallMap_head.style.top = "5%";
        div_smallMap_head.style.position = "absolute";
        div_smallMap_head.style.zIndex = "1";
        let map_handler = L.map('Map_showPaths', { preferCanvas: true }).setView([0, 0], 8);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 20,
            // attribution: '&copy; <a href="https://stadiamaps.com/">Stadia Maps</a>, &copy; <a href="https://openmaptiles.org/">OpenMapTiles</a> &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors'
        }).addTo(map_handler);

        showInMap(demo_singleRoute);

        function showInMap(path) {

            var path_normalize = [];
            for (var i = 0; i < path.length; i++) {
                var cell = [];
                cell.push(path[i]['latitude']);
                cell.push(path[i]['longitude']);
                path_normalize.push(cell);
            }
            console.log(path_normalize.length);
            for (var i = 0; i < path_normalize.length; i++) {
                if (i == 0) {
                    map_handler.setView(path_normalize[Math.floor(path_normalize.length / 2)], 9)
                    // map_handler.setView(path_normalize[0], 10)
                }
                drawPath(path_normalize);
            }
            var baseLine = [path_normalize[0], path_normalize[path_normalize.length - 1]];
            console.log(baseLine.length);
            L.polyline(baseLine, { color: 'blue', weight: '1' }).addTo(map_handler);

            function drawPath(pathLine_origin) {
                // let pathName = '{{ pathName|safe }}';
                // let pathLine_origin = '{{ pathLine_origin|safe }}'

                console.log(typeof (pathLine_origin));
                // console.log(pathLine_origin);
                var pathLine_origin_normalized = pathLine_origin;
                // console.log(typeof (pathLine_origin_normalized));
                // console.log(pathLine_origin_normalized);

                var polyline_origin = L.polyline(pathLine_origin_normalized, { color: 'red', weight: '1' }).addTo(map_handler);
                // var polyline_filtered = L.polyline(pathLine_filter_normalized, { color: 'yellow' }).addTo(map_handler);
                // var polygon = L.polygon(pathPolygon_normalized).addTo(map_handler);

            }
        }
    }
  </script>
</body>

</html>