<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.5.0/Chart.js"></script>
  <!-- Include 2d map tools -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"
    integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A=="
    crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"
    integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA=="
    crossorigin=""></script>
  <script src='https://unpkg.com/@turf/turf@6/turf.min.js'></script>
  <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
  <style>
    .anybutton {
      bottom: 5%;
      left: 45%;
      /* width:100px;
        height:40px; */
      position: relative;
      z-index: 2;
      /* background: orange;  */
    }
  </style>
</head>

<body>
  <table id="table_pigeonNumber">
    <thead>
        <tr>
            <th></th>
            <th>勾選</th>
            <th>公環號碼</th>
            <th>gps腳環</th>
        </tr>
    </thead>
    <tbody id="table_pigeonNumber_body">
    </tbody>
  </table>
  <div id="Map_showPaths"></div>
  <div id="Map_showPaths_routeSimilarity"></div>
  <div id="div_smallMap_routeSimilarity_threeroutes"></div>
  <dialog id="dialog_routeEfficiency">
    <form method="dialog">
        <p style="font-size:30px"><label>路徑效率:</label>
        </p>
        <p><label>“路徑效率”是量化鴿子導航能力的一個方式。通過量化鴿子導航能力，能夠追蹤鴿子導航能力的水平和變化，並進行針對性訓練。</label>
        </p>
        <p><label>目前，鴿鐘的做法：只能提供直線分速（直線距離/時間）作爲成績判斷的標準。但是這項數據如果要用來呈現訓練以及比賽歷程，甚至要進行科學化的訓練分析來提升飛行效率，是不夠的。</label>
        </p>
        <p><label>爲了進行科學量化分析，衡量訓練是否有效，參考了多篇論文，引用論文中判斷訓練模型是否有效所採用的路徑效率，來進行分析跟參考：</label>
        </p>
        <p><label>量化導航能力的方式是：比較飛行的路經的效率。把導航能力量化為，“路徑效率”：</label>
        </p>
        <p style="font-size:24px;font-weight:bold"><label>公式：路徑效率 = 直線距離 / 飛行距離。</label>
        </p>
        <p><label>驗證：比賽成績 = 分速 = 直線距離/實際飛行時間 = （實際飛行距離*路徑效率）/實際飛行時間=（實際飛行距離/實際飛行時間）*路徑效率=實際飛行分速*路徑效率。。</label>
        </p>
        <div>
            <button id="confirmBtn_dialog_routeEfficiency" value="default" style="font-size:22px" class="anybutton"">確認</button>
        </div>
    </form>
  </dialog>
  <dialog id="dialog_routeEfficiency_realtime">
    <form method="dialog">
        <p style="font-size:30px"><label>即時路徑偏移量:</label>
        </p>
        <p style="font-size:24px;font-weight:bold"><label>公式：偏離距離=D點到直線</label>
        </p>
        <p><label>用途：量化當前點的偏離直線的情況，偏離的越多，說明當前的路徑準確度越低；</label>
        </p>
        <div>
            <button id="confirmBtn_dialog_routeEfficiency_realtime" value="default" style="font-size:22px" class="anybutton"">確認</button>
        </div>
    </form>
  </dialog>
  <dialog id="dialog_altitudeFromEarth">
    <form method="dialog">
        <p style="font-size:30px"><label>離地高度:</label>
        <p style="font-size:24px;font-weight:bold"><label>公式：離地高度 = 海拔 - 地面海拔；</label>
        </p>
        <div>
            <button id="confirmBtn_dialog_routeEfficiency_realtime" value="default" style="font-size:22px" class="anybutton"">確認</button>
        </div>
    </form>
  </dialog>
  <dialog id="dialog_elevationZoneBar">
    <form method="dialog">
        <p style="font-size:30px"><label>quatile做法:</label>
        <p style="font-size:24px"><label>按照從小到大的方式排列成有序的list，然後25%是指位置在25%的數值，50%就是指中位數，75%是位置在75%的值；</label>
        </p>
        <div>
            <button id="confirmBtn_dialog_routeEfficiency_realtime" value="default" style="font-size:22px" class="anybutton"">確認</button>
        </div>
    </form>
  </dialog>
  <dialog id="dialog_realTimeDistance">
    <form method="dialog">
        <p style="font-size:30px"><label>即時距離:</label>
        <p><label>論文中用這個公式來判斷鴿子是否是pair飛行的，可以作為pair飛行的驗證工具；</label>
        </p>
        <p style="font-size:24px;font-weight:bold"><label>公式：即時距離 = D點到點的距離（timestamp）；</label>
        </p>
        <div>
            <button id="confirmBtn_dialog_routeEfficiency_realtime" value="default" style="font-size:22px" class="anybutton"">確認</button>
        </div>
    </form>
  </dialog>
  <dialog id="dialog_routeSimilarity">
    <form method="dialog">
        <p style="font-size:30px"><label>路徑相似度:</label>
        <p><label>論文中計算所有點到參考路線的距離，計算平均距離，平均距離越小，相似度越高；</label>
        </p>
        <p><label>用法：輔佐路徑效率，判斷鴿子是否對熟悉了某個定點飛行的路線；</label>
        </p>
        <p style="font-size:24px;font-weight:bold"><label>公式：相似度 = {D點到參考路徑}；</label>
        </p>
        <div>
            <button id="confirmBtn_dialog_routeEfficiency_realtime" value="default" style="font-size:22px" class="anybutton"">確認</button>
        </div>
    </form>
  </dialog>
  <dialog id="dialog_leaderOfGroup">
    <form method="dialog">
        <p style="font-size:30px"><label>羣體飛行的領航者:</label>
        <p><label>不論是pair飛行，還是group飛行，我們都希望能夠找到誰是飛行的leader。</label>
        </p>
        <p><label>引用論文中的理論：判斷誰的位置更靠前，來判斷誰是leader。</label>
        </p>
        <p><label>使用從“出發點”到“當前點”的“投影距離”（投影到起始點和終點的直線），來判斷位置，投影距離越大位置越更靠前。</label>
        </p>
        <p style="font-size:24px;font-weight:bold"><label>公式：D投影距離 = 開方（平方（D起點到當前點）-平方（D當前點到直線））</label>
        </p>
        <div>
            <button id="confirmBtn_dialog_routeEfficiency_realtime" value="default" style="font-size:22px" class="anybutton"">確認</button>
        </div>
    </form>
  </dialog>
  <script>
    let routeIds = '{{ routeIds|safe }}';
    let routeId_list = routeIds.split(',');
    let map_pigeonGps_routeIndex = {};
    let pigeonNumbers_gpsNumbers = [];
    let routes_origin = [];
    console.log(routeId_list);

    request_askRoutesData()
    function request_askRoutesData() {
      function reqListener() {
        // console.log(typeof (this.responseText), typeof (this.response));
        // console.log(this.responseText)

        var response = JSON.parse(this.responseText);
        for(var i=0;i<routeId_list.length;i++)
        {
          routeId = routeId_list[i];
          var route = response[routeId];
          routes_origin.push(route);
          var summary = response[routeId+'pigeonNumber'];
          pigeonNumbers_gpsNumbers.push({'pigeonNumber':summary['recordname'],'gps_id':summary['gps_id']});
          console.log(pigeonNumbers_gpsNumbers);
          // pigeonNumbers.push(pigeonNumber);
          // map_pigeonNumber_routeIndex[pigeonNumber] = routes_origin.length-1;
        }
        // tracks_showInTable(pigeonNumbers)
        show_figures(routes_origin);

        // var routes =  Object.values(response);
        // // console.log(Object.values(response));
        // console.log(routes);
        // tracks_showInTable(routeId_list)
        // show_figures(routes);
      }

      var oReq = new XMLHttpRequest();
      oReq.addEventListener("load", reqListener);
      oReq.open("post", 'figures/askTracksData');
      oReq.setRequestHeader("X-CSRFToken", '{{ csrf_token|safe }}');
      // oReq.setRequestHeader("Content-Type", "text/plain;charset=UTF-8");   
      oReq.send(routeId_list.toString());
    }

    function tracks_showInTable(routeId_list) {
            let table_pigeonNumber_body = document.getElementById('table_pigeonNumber_body');
            for (var i = 0; i < routeId_list.length; i++) {
                func_table_track_addData(routeId_list[i]);
            }
            function func_table_track_addData(routeId) {
                var row = document.createElement('tr');
                var row_data_0 = document.createElement("INPUT");
                row_data_0.setAttribute("type", "checkbox");
                // row_data_0.style.position = 'absolute';
                // row_data_0.style.top = '30%';
                var row_data_1 = document.createElement('td');
                row_data_1.innerHTML = routeId;
             // row_data_1.style.textAlign = "center";

                row.appendChild(row_data_0);
                row.appendChild(row_data_1);
                table_pigeonNumber_body.appendChild(row);
            }
    }



    function show_figures(test_demo_data)
    {
        console.log(test_demo_data.length);
        ///set source data
        const demo_singleRoute = test_demo_data[0];
        console.log(demo_singleRoute.length);
        ///draw path in map
        let div_smallMap_head = document.getElementById('Map_showPaths');
        div_smallMap_head.setAttribute('style', 'width:70%;height:50%;');
        div_smallMap_head.style.left = "20%";
        // div_smallMap_head.style.top = "5%";
        div_smallMap_head.style.position = "absolute";
        div_smallMap_head.style.zIndex = "1";
        let map_handler = L.map('Map_showPaths', { preferCanvas: true }).setView([0, 0], 8);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 20,
            // attribution: '&copy; <a href="https://stadiamaps.com/">Stadia Maps</a>, &copy; <a href="https://openmaptiles.org/">OpenMapTiles</a> &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors'
        }).addTo(map_handler);

        showInMap(demo_singleRoute);

        function showInMap(path,filtered_route =false) {

            var path_normalize = [];
            for (var i = 0; i < path.length; i++) {
                var cell = [];
                cell.push(parseFloat(path[i]['latitude']));
                cell.push(parseFloat(path[i]['longitude']));
                path_normalize.push(cell);
            }
            console.log(path_normalize);

            map_handler.setView(path_normalize[0], 10);
            var baseLine = [path_normalize[0], path_normalize[path_normalize.length - 1]];
            // console.log(baseLine.length);
            // L.polyline(baseLine, { color: 'blue', weight: '1' }).addTo(map_handler);

            if(filtered_route)
            {
              drawPath(path_normalize,'red','3');
            }
            else
            {
              drawPath(path_normalize,'blue','1');
            }
            
            function drawPath(pathLine_origin,color,weight) {
                console.log(typeof (pathLine_origin));
                // console.log(pathLine_origin);
                var pathLine_origin_normalized = pathLine_origin;
                // console.log(typeof (pathLine_origin_normalized));
                // console.log(pathLine_origin_normalized);

                var polyline_origin = L.polyline(pathLine_origin_normalized, { color: color, weight: weight }).addTo(map_handler);
                // var polyline_filtered = L.polyline(pathLine_filter_normalized, { color: 'yellow' }).addTo(map_handler);
                // var polygon = L.polygon(pathPolygon_normalized).addTo(map_handler);

            }
        }

        //draw a point in map
        let soloRoute_routeAccuracy_realTime_movingPoint = L.circle([0, 0], { radius: 1600 }).addTo(map_handler);;

        function showInMap_movepoint(point) {
            soloRoute_routeAccuracy_realTime_movingPoint.setLatLng(L.latLng(point[0], point[1]));
            var zoomLevel = map_handler.getZoom();
            console.log(zoomLevel);
            if((zoomLevel-10)>0)
            {
              soloRoute_routeAccuracy_realTime_movingPoint.setRadius(300/(zoomLevel-10));
            }
            map_handler.setView(point);
        }

        class Route_Filter
        {
          constructor() { 
            this.filter_start = false;
            this.filter_end = false;
            this.route_index = -1;
            this.startIndex = -1;
          }

          getStatus_filter()
          {
            return this.filter_start;
          }

          start_filter(index_inDemoRoutes,index_startToFilter)
          {
            if(index_inDemoRoutes>=0&&index_inDemoRoutes<test_demo_data.length)
            {
              if(index_startToFilter>=0&&index_startToFilter<test_demo_data[index_inDemoRoutes].length)
              {
                this.filter_start=true;
                this.route_index = index_inDemoRoutes;
                this.startIndex = index_startToFilter;

                return true;
              }
            }
            return false;
          }
          endFilter_GetFilteredRoutes(index_endFilter)
          {
            if(this.filter_start == true)
            {
              if(index_endFilter>=this.startIndex&&index_endFilter<test_demo_data[this.route_index].length)
              {
                {
                  this.filter_start = false;
                  return test_demo_data[this.route_index].slice(this.startIndex,index_endFilter);
                }
              }
            }
          }
        }

        let route_filter_handler = new Route_Filter();

        func_label_solo_route_SpeedElevation('70%');
        //draw a label for route accuracy
        function func_label_solo_route_SpeedElevation(top) {
            const newLabel = document.createElement("label");
            newLabel.style.width = '100%';
            newLabel.style.height = '48px';
            newLabel.style.left = "0%";
            newLabel.style.top = top;
            newLabel.style.backgroundColor = "rgba(106,90,205,0.5)";
            newLabel.style.position = "absolute";
            newLabel.style.zIndex = "1";
            newLabel.innerHTML = "速度.海拔.地面海拔的對比圖";
            newLabel.style.textAlign = "left";
            newLabel.style.fontSize = '36px';

            document.body.appendChild(newLabel);

            var dialog = document.getElementById('dialog_altitudeFromEarth');
            newLabel.addEventListener('click', () => {
                if (typeof dialog.showModal === "function") {
                    dialog.showModal();
                } else {
                    alert("Sorry, the <dialog> API is not supported by this browser.");
                }
            });
        }

        func_solo_route_SpeedElevation("80%");
        ///functions for solo route's figures analysis
        function func_solo_route_SpeedElevation(top) {
            var data_normalized = []

            for (var i = 0; i < demo_singleRoute.length; i++) {
                data_normalized.push([demo_singleRoute[i]['latitude'], demo_singleRoute[i]['longitude']]);
            }

            function makeYData_elevation() {
                var result = []
                for (var i = 0; i < demo_singleRoute.length; i++) {
                    result.push(demo_singleRoute[i]['elevation'] / 1000)
                }
                return result;
            }
            var dataY_elevation = makeYData_elevation();
            //draw in plot
            //set chart
            var canvas_routeEff_speed_elevation = document.createElement('div');
            canvas_routeEff_speed_elevation.style.width = '99%';
            canvas_routeEff_speed_elevation.style.height = '30%';
            canvas_routeEff_speed_elevation.setAttribute("id", "canvas_routeEff_speed_elevation");
            canvas_routeEff_speed_elevation.style.left = "0%";
            // console.log((250+(i-1)*50).toString(10));
            canvas_routeEff_speed_elevation.style.top = top;
            canvas_routeEff_speed_elevation.style.position = "absolute";
            document.body.appendChild(canvas_routeEff_speed_elevation);

            function makeYData_speed() {
                var result = []
                for (var i = 0; i < demo_singleRoute.length; i++) {
                    result.push(demo_singleRoute[i]['speed'] * 60 / 1000);
                }
                return result;
            }
            var dataY_speed = makeYData_speed();

            function makeYData_elevation() {
                var result = []
                for (var i = 0; i < demo_singleRoute.length; i++) {
                    result.push(demo_singleRoute[i]['elevation'] / 1000)
                }
                return result;
            }
            var dataY_elevation = makeYData_elevation();

            //set options
            var options = {
                series: [
                    {
                        name: '速度(km/min)',
                        data: dataY_speed,
                    },
                    {
                        name: '海拔(km)',
                        data: dataY_elevation,
                    },
                ],
                chart: {
                    height: 350,
                    type: 'line',
                    zoom: {
                        enabled: false
                    },
                    events: {
                      mouseMove: function (event, chartContext, config) {
                          try {
                              showInMap_movepoint(data_normalized[config['dataPointIndex']]);
                          } catch (e) {
                              console.log(e); // Error: hi
                          }
                      },
                      click: function(event, chartContext, config) {
                      // The last parameter config contains additional information like `seriesIndex` and `dataPointIndex` for cartesian charts
                        try {
                              if(route_filter_handler.getStatus_filter() == false)
                              {
                                console.log(config['dataPointIndex']);
                                route_filter_handler.start_filter(0, config['dataPointIndex']);
                              }
                              else
                              {
                                var filtered_route =  route_filter_handler.endFilter_GetFilteredRoutes(config['dataPointIndex']);
                                showInMap(filtered_route,true);
                                show_figures_byFilteredRoutes_soloPigeon_routeEffProcess([filtered_route]);
                              }
                            } catch (e) {
                                console.log(e); // Error: hi
                            }
                    }
                  },
                },
                colors: ['#77B6EA', '#545454', '#7CFC00', '#b84644', '#4576b5'],
                // colors: ['#545454', '#7CFC00','#b84644', '#4576b5'],
                dataLabels: {
                    enabled: false
                },
                stroke: {
                    curve: 'straight'
                },
                title: {
                    text: '速度.海拔.地面海拔的對比圖',
                    align: 'left'
                },
                grid: {
                    row: {
                        colors: ['#f3f3f3', 'transparent'], // takes an array which will be repeated on columns
                        opacity: 0.5
                    },
                },
                legend: {
                    position: 'top',
                    horizontalAlign: 'right',
                    floating: true,
                    offsetY: -25,
                    offsetX: -5
                }
            };

            var chart = new ApexCharts(canvas_routeEff_speed_elevation, options);
            chart.render();

            function draw_earthElevation(elevations) {
                var normalized_elevations = [];
                for (var i = 0; i < elevations.length; i++) {
                    normalized_elevations.push(elevations[i] / 1000);
                }
                var make_data = {
                    name: '地面海拔(km)',
                    data: normalized_elevations,
                }
                console.log(chart);
                chart.opts.series.push(make_data);
                // chart.opts.colors.push();
                chart.update();
            }

            function draw_elevationFromEarth(elevations) {
                var normalized_elevations = [];
                for (var i = 0; i < elevations.length; i++) {
                    normalized_elevations.push(dataY_elevation[i] - elevations[i] / 1000);
                }
                var make_data = {
                    type: 'line',
                    label: '離地高度(km)',
                    data: normalized_elevations,
                    // backgroundColor: 'transparent',
                    fill: false,
                    borderColor: 'green',
                }
                myChart_RoutePlot.data.datasets.push(make_data);
                myChart_RoutePlot.update();
            }

            // makeYData_earthElevation();

            function makeYData_earthElevation() {
                var result = [];
                var dataToSend = "";
                var dataToSend_json = [];
                for (var i_earthEle = 0; i_earthEle < data_normalized.length; i_earthEle++) {
                    var lat = data_normalized[i_earthEle][0];
                    var lon = data_normalized[i_earthEle][1];

                    dataToSend_json.push({ "latitude": lat, "longitude": lon });
                }

                const url = 'https://api.open-elevation.com/api/v1/lookup?';
                var oReq = new XMLHttpRequest();

                function reqListener() {
                    // console.log(typeof (this.responseText), typeof (this.response));
                    // console.log(this);

                    var response = JSON.parse(this.responseText);
                    console.log(response.results);
                    for (var i_res = 0; i_res < response.results.length; i_res++) {
                        result.push(response.results[i_res]['elevation']);
                    }
                    console.log(result);
                    //todo draw in chart
                    draw_earthElevation(result);
                    // draw_elevationFromEarth(result);
                }

                oReq.addEventListener("load", reqListener);
                // oReq.open("GET", 'decodePathLine_toPolygon' + '/' + pathname + '/' + str_paths);
                oReq.open("post", url);
                // oReq.setRequestHeader("X-CSRFToken", '{{ csrf_token|safe }}');
                oReq.setRequestHeader("Accept", "application/json");
                oReq.setRequestHeader("Content-Type", "application/json");
                oReq.send(JSON.stringify({ "locations": dataToSend_json }));
            }

        }
    }
    
    function show_figures_byFilteredRoutes_soloPigeon_routeEffProcess(test_demo_data)
    {
      var pre_label = document.getElementById('label_soloPigeon_routeEffProcess');
      if(pre_label)
      {
        pre_label.remove();
      }
      func_label_soloPigeon_routeEff_process('150%');
      //draw a label for route accuracy
      function func_label_soloPigeon_routeEff_process(top) {
          const newLabel = document.createElement("label");
          newLabel.setAttribute('id','label_soloPigeon_routeEffProcess')
          newLabel.style.width = '100%';
          newLabel.style.height = '48px';
          newLabel.style.left = "0%";
          newLabel.style.top = top;
          newLabel.style.backgroundColor = "rgba(106,90,205,0.5)";
          newLabel.style.position = "absolute";
          newLabel.style.zIndex = "1";
          newLabel.innerHTML = "單鴿路徑效率process圖";
          newLabel.style.textAlign = "left";
          newLabel.style.fontSize = '36px';

          document.body.appendChild(newLabel);

          var dialog = document.getElementById('dialog_routeEfficiency');
          newLabel.addEventListener('click', () => {
              if (typeof dialog.showModal === "function") {
                  dialog.showModal();
              } else {
                  alert("Sorry, the <dialog> API is not supported by this browser.");
              }
          });
      }

      func_multiRoutes_routeEff_process('170%');

      function func_multiRoutes_routeEff_process(top) {    
          var pre_canvas = document.getElementById('canvas_soloPigeon_routeEffProcess');
          if(pre_canvas)
          {
            pre_canvas.remove();
          }
          //normalize routes
          var normalized_multiroutes = [];
          for (var i = 0; i < test_demo_data.length; i++) {
              var normalized_route = [];
              for (var j = 0; j < test_demo_data[i].length; j++) {
                  normalized_route.push([test_demo_data[i][j]['latitude'], test_demo_data[i][j]['longitude']]);
              }
              normalized_multiroutes.push(normalized_route);
          }
          console.log(normalized_multiroutes);

          //calculate route effs
          var routes_effs = [];
          for (var i = 0; i < normalized_multiroutes.length; i++) {
              var cur_route = normalized_multiroutes[i];
              var start_point = turf.point(cur_route[0]);
              var end_Point = turf.point(cur_route[cur_route.length - 1]);
              var baselineDistance = turf.distance(start_point, end_Point, { units: 'kilometers' }) * 1000;

              var realDistance = 0;
              for (var j = 0; j < cur_route.length; j++) {
                  realDistance += parseFloat(test_demo_data[i][j]['distance']);
              }
              var routeEff = baselineDistance / realDistance;
              routes_effs.push(routeEff.toFixed(4));
          }

          var data_x = [];
          for (var i = 0; i < routes_effs.length; i++) {
              data_x.push(i);
          }

          draw_line_routeEffs();

          function draw_line_routeEffs() {
              var options = {
                  series: [{
                      name: "路徑效率",
                      data: routes_effs
                  }],
                  chart: {
                      // height: 800,
                      type: 'line',
                      zoom: {
                          enabled: false
                      }
                  },
                  dataLabels: {
                      enabled: false
                  },
                  stroke: {
                      curve: 'straight'
                  },
                  title: {
                      text: '路徑效率process圖:路徑效率/放飛次數',
                      align: 'middle'
                  },
                  grid: {
                      row: {
                          colors: ['#f3f3f3', 'transparent'], // takes an array which will be repeated on columns
                          opacity: 0.5
                      },
                  },
                  xaxis: {
                      numeric: data_x,
                  }
              };


              //set chart
              var canvas_routeEffs_process = document.createElement('div');
              canvas_routeEffs_process.style.width = '50%';
              canvas_routeEffs_process.style.height = '50%';
              canvas_routeEffs_process.setAttribute("id", "canvas_soloPigeon_routeEffProcess");
              canvas_routeEffs_process.style.left = "30%";
              // console.log((250+(i-1)*50).toString(10));
              canvas_routeEffs_process.style.top = top;
              canvas_routeEffs_process.style.position = "absolute";
              document.body.appendChild(canvas_routeEffs_process);
              var chart = new ApexCharts(canvas_routeEffs_process, options);
              chart.render();
          }

      }
    }
  </script>
</body>

</html>