<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.5.0/Chart.js"></script>
  <!-- Include 2d map tools -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"
    integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A=="
    crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"
    integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA=="
    crossorigin=""></script>
  <!-- <script src="https://unpkg.com/leaflet@1.4.0/dist/leaflet.js"></script>
  <script src="https://api.windy.com/assets/map-forecast/libBoot.js"></script> -->
  <script src='https://unpkg.com/@turf/turf@6/turf.min.js'></script>
  <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
  <style>
    .button {
            background-color: #FFED86;
            border: none;
            color: black;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            position: relative;
            cursor: pointer;
    }

    .button:hover{
    /* border: 1px solid #888; */
    background-color: #ddd;
    }

    table {
        border-collapse: collapse;
        /* width: 20%; */
        cursor: pointer;
    }

    th, td {
        padding: 8px;
        text-align: left;
        border-bottom: 1px solid #ddd;
    }

    tr:hover {
        background-color: coral;
    }

    .label_plots {
        display: block;
        /* width: 130px; */
        width : 100%;
        height: 48px;
        background-color : rgba(106,90,205,0.5);
        text-align: "left";
        font-size : 36px;
        cursor : help;
    }
    .myDiv_map {
        border: 1px outset black;
        background-color: lightblue;    
        text-align: center;
        width:100%;
        height: 400px;
    }
    .myDiv_plots {
        border: 1px outset black;
        background-color: transparent;    
        text-align: center;
        width:100%;
        height: 500px;
    }
    .myDiv_chart {
        width:100%;
        height: 40%;
    }

    /* #windy {
        width: 100%;
        height: 400px;
    } */

  </style>
</head>

<body>

  <!-- <div id="Map_showPaths" class="myDiv_map"></div>
  <br>
  </br> -->
  <table id="table_pigeonNumber">
    <thead>
        <tr>
            <th></th>
            <th>公環號碼</th>
            <th>放飛時間</th>
            <th>實際飛行距離(m)</th>
            <!-- <th>時間</th> -->
            <th>實際飛行速度(m/min)</th>
            <th>直線距離(m)</th>
            <th>直線分速(m/min)</th>
            <th>路徑效率</th>
            <th>是否裁減</th>
        </tr>
    </thead>
    <tbody id="table_pigeonNumber_body" title="雙擊查看速度海拔並進行裁減">
    </tbody>
  </table>
  <!-- <br>
  </br> -->
  <button id="button_showFigures_FilteredRoutes" class="button" title="裁減完後，點擊顯示特徵圖">顯示特徵圖</button>
  <br>
  </br>
  <!-- <button id="button_windy_showPath" class="button" title="點擊查看軌跡">顯示路徑</button>
  <br>
  </br> -->
  <!-- <div id="windy"></div> -->
  <div id ='solo_route_SpeedElevation' class = 'myDiv_plots' >
    <label id="label_solo_route_SpeedElevation" class="label_plots">裁減：點擊圖表進行裁減</label>
    <br></br>
    <div id="canvas_speed_elevation_forFilterRoutes" class="myDiv_chart"></div>
  </div>
  <div id="map_showroutes" class="myDiv_map"></div>
  <br>
  </br>
  <div id ='routeEff_Polyline_plot' class = 'myDiv_plots' >
    <label id="label_routeEff_Polyline_plot" class="label_plots">路徑效率折線圖</label>
    <br></br>
    <div id="canvas_routeEff_Polyline_plot" class="myDiv_chart"></div>
  </div>
  <!-- <div id ='distancefrombeeline_realtime_boxplot' class = 'myDiv_plots' >
    <label id="label_distancefrombeeline_realtime_boxplot" class="label_plots">即時路徑偏移量箱圖</label>
    <br></br>
    <div id="canvas_distancefrombeeline_realtime_boxplot" class="myDiv_chart"></div>
  </div> -->
  <div id ='multiRoutes_routeSimilarity' class = 'myDiv_plots' >
    <label id="label_multiRoutes_routeSimilarity" class="label_plots">路徑相似度</label>
    <br></br>
    <div id="canvas_multiRoutes_routeSimilarity" class="myDiv_chart"></div>
  </div>
  <div id="Map_showPaths_routeSimilarity"></div>
  <div id="div_smallMap_routeSimilarity_threeroutes"></div>
  <!-- <div id="canvas_speed_elevation_forFilterRoutes"></div> -->
  <dialog id="dialog_routefilter">
    <form method="dialog">
        <p style="font-size:30px"><label>裁減:</label>
        <p style="font-size:24px;font-weight:bold"><label>點擊兩次圖表進行裁減，第一次點擊左側起始點，第二次點擊右側終點</label>
        </p>
        <div>
            <button id="confirmBtn_dialog_routeEfficiency_realtime" value="default" style="font-size:22px" class="anybutton"">確認</button>
        </div>
    </form>
  </dialog>
  <dialog id="dialog_routeEfficiency">
    <form method="dialog">
        <p style="font-size:30px"><label>路徑效率:</label>
        </p>
        <p><label>“路徑效率”是量化鴿子導航能力的一個方式。通過量化鴿子導航能力，能夠追蹤鴿子導航能力的水平和變化，並進行針對性訓練。</label>
        </p>
        <p><label>目前，鴿鐘的做法：只能提供直線分速（直線距離/時間）作爲成績判斷的標準。但是這項數據如果要用來呈現訓練以及比賽歷程，甚至要進行科學化的訓練分析來提升飛行效率，是不夠的。</label>
        </p>
        <p><label>爲了進行科學量化分析，衡量訓練是否有效，參考了多篇論文，引用論文中判斷訓練模型是否有效所採用的路徑效率，來進行分析跟參考：</label>
        </p>
        <p><label>量化導航能力的方式是：比較飛行的路經的效率。把導航能力量化為，“路徑效率”：</label>
        </p>
        <p style="font-size:24px;font-weight:bold"><label>公式：路徑效率 = 直線距離 / 飛行距離。</label>
        </p>
        <p><label>驗證：比賽成績 = 分速 = 直線距離/實際飛行時間 = （實際飛行距離*路徑效率）/實際飛行時間=（實際飛行距離/實際飛行時間）*路徑效率=實際飛行分速*路徑效率。。</label>
        </p>
        <div>
            <button id="confirmBtn_dialog_routeEfficiency" value="default" style="font-size:22px" class="anybutton"">確認</button>
        </div>
    </form>
  </dialog>
  <dialog id="dialog_routeEfficiency_realtime">
    <form method="dialog">
        <p style="font-size:30px"><label>即時路徑偏移量:</label>
        </p>
        <p style="font-size:24px;font-weight:bold"><label>公式：偏離距離=D點到直線</label>
        </p>
        <p><label>用途：量化當前點的偏離直線的情況，偏離的越多，說明當前的路徑準確度越低；</label>
        </p>
        <div>
            <button id="confirmBtn_dialog_routeEfficiency_realtime" value="default" style="font-size:22px" class="anybutton"">確認</button>
        </div>
    </form>
  </dialog>
  <dialog id="dialog_altitudeFromEarth">
    <form method="dialog">
        <p style="font-size:30px"><label>離地高度:</label>
        <p style="font-size:24px;font-weight:bold"><label>公式：離地高度 = 海拔 - 地面海拔；</label>
        </p>
        <div>
            <button id="confirmBtn_dialog_routeEfficiency_realtime" value="default" style="font-size:22px" class="anybutton"">確認</button>
        </div>
    </form>
  </dialog>
  <dialog id="dialog_elevationZoneBar">
    <form method="dialog">
        <p style="font-size:30px"><label>quatile做法:</label>
        <p style="font-size:24px"><label>按照從小到大的方式排列成有序的list，然後25%是指位置在25%的數值，50%就是指中位數，75%是位置在75%的值；</label>
        </p>
        <div>
            <button id="confirmBtn_dialog_routeEfficiency_realtime" value="default" style="font-size:22px" class="anybutton"">確認</button>
        </div>
    </form>
  </dialog>
  <dialog id="dialog_realTimeDistance">
    <form method="dialog">
        <p style="font-size:30px"><label>即時距離:</label>
        <p><label>論文中用這個公式來判斷鴿子是否是pair飛行的，可以作為pair飛行的驗證工具；</label>
        </p>
        <p style="font-size:24px;font-weight:bold"><label>公式：即時距離 = D點到點的距離（timestamp）；</label>
        </p>
        <div>
            <button id="confirmBtn_dialog_routeEfficiency_realtime" value="default" style="font-size:22px" class="anybutton"">確認</button>
        </div>
    </form>
  </dialog>
  <dialog id="dialog_routeSimilarity">
    <form method="dialog">
        <p style="font-size:30px"><label>路徑相似度:</label>
        <p><label>路徑相似度是爲了比較兩條路徑的相似程度，比較方式是：按照兩條路徑之間的距離進行比較；距離越小，相似度越高，距離越大，相似度越低；</label>
        </p>
        <p><label>那摩，兩條路徑的距離如何計算呢？因爲路徑不是平行的直線，所以無法直接使用線與線的距離計算，而是使用點到線的距離進行計算。</label>
        </p>
        <p><label>比如計算路徑A到路徑B的距離，以A爲參考路徑，B爲爲計算路徑，B是由n個路徑點組成的，計算每個路徑點到A的距離，取這些距離的集合or平均值。</label>
        </p>
        <p><label>用法：輔佐路徑效率，判斷鴿子是否對熟悉了某個定點飛行的路線；</label>
        </p>
        <p style="font-size:24px;font-weight:bold"><label>公式：相似度 = {D點到參考路徑}；</label>
        </p>
        <p><label>箱圖和quatile做法說明:</label>
            <p><label>上下的黑線表示最大和最小值；</label> </p>
            <p><label>箱子：按照從小到大的方式排列成有序的list，然後Q1是指位置在25%的數值，median是指中位數，Q3是位置在75%的值；藍色表示Q1～median，綠色表示median～Q3。</label>
            </p>
        <div>
            <button id="confirmBtn_dialog_routeEfficiency_realtime" value="default" style="font-size:22px" class="anybutton"">確認</button>
        </div>
    </form>
  </dialog>
  <dialog id="dialog_leaderOfGroup">
    <form method="dialog">
        <p style="font-size:30px"><label>羣體飛行的領航者:</label>
        <p><label>不論是pair飛行，還是group飛行，我們都希望能夠找到誰是飛行的leader。</label>
        </p>
        <p><label>引用論文中的理論：判斷誰的位置更靠前，來判斷誰是leader。</label>
        </p>
        <p><label>使用從“出發點”到“當前點”的“投影距離”（投影到起始點和終點的直線），來判斷位置，投影距離越大位置越更靠前。</label>
        </p>
        <p style="font-size:24px;font-weight:bold"><label>公式：D投影距離 = 開方（平方（D起點到當前點）-平方（D當前點到直線））</label>
        </p>
        <div>
            <button id="confirmBtn_dialog_routeEfficiency_realtime" value="default" style="font-size:22px" class="anybutton"">確認</button>
        </div>
    </form>
  </dialog>
  <script>
    let routeIds = '{{ routeIds|safe }}';
    let routeId_list = routeIds.split(',');
    let map_pigeonNumberReleaseTime_routeIndex = [];
    let map_routeIndex_pigeonNumberReleaseTime = {};
    let pigeonNumbers_releaseTime = [];
    let routes_origin = [];
    console.log(routeId_list);
    //for Map_showPaths
    let lineObjects_in_Map_showPaths = [];
    let map_handler = L.map('map_showroutes', { preferCanvas: true }).setView([0, 0], 8);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 20,
            // attribution: '&copy; <a href="https://stadiamaps.com/">Stadia Maps</a>, &copy; <a href="https://openmaptiles.org/">OpenMapTiles</a> &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors'
    }).addTo(map_handler);

    //for windy
    function getRandomColor() {
        var letters = '0123456789ABCDEF';
        var color = '#';
        for (var i = 0; i < 6; i++) {
            color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
    }

    let lineObjects_in_windy = [];
    let windy_map_handler = null;
    let windy_map_handler_layer = null;
    // let map_handler = null;
    // let map_layer_windy = null;
    let map_layer_windy = L;
    let func_point_showRoutesInMap = null;
    
    // const options_windy_init = {
    //             // Required: API key
    //             key: 'SpQ9lG1cm8zd0VFmrgk1FBYRMWd4F8Gk', // REPLACE WITH YOUR KEY !!!

    //             // Put additional console output
    //             verbose: true,

    //             // Optional: Initial state of the map
    //             lat: 0,
    //             lon: 0,
    //             zoom: 10,
    // };

    //         // Initialize Windy API
    // windyInit(options_windy_init, windyAPI => {
    //             // windyAPI is ready, and contain 'map', 'store',
    //             // 'picker' and other usefull stuff

    //             const { map } = windyAPI;
    //             // .map is instance of Leaflet map
    //             // map.setView(path_normalize_list[0][0],10);
    //             map_handler = map;

    //     L.popup()
    //         .setLatLng([0,0])
    //         // .setContent('begin')
    //         .openOn(map);
                
    //     map_layer_windy = L;

    //     // windy_movingPoint = windy_map_handler_layer.circle(path_normalize_list[0][0], { radius: 1600 }).addTo(windy_map_handler);

    // });

    let windy_movingPoint = null;

    //for canvas_speed_elevation_forFilterRoutes
    func_label_solo_route_SpeedElevation();
    //draw a label for route accuracy
    function func_label_solo_route_SpeedElevation() {
            var label = document.getElementById('label_solo_route_SpeedElevation');
            var dialog = document.getElementById('dialog_routefilter');
            label.addEventListener('click', () => {
                if (typeof dialog.showModal === "function") {
                    dialog.showModal();
                } else {
                    alert("Sorry, the <dialog> API is not supported by this browser.");
                }
            });
    }
    //set chart
    var canvas_speed_elevation_forFilterRoutes = document.getElementById('canvas_speed_elevation_forFilterRoutes');

    let chart_canvas_speed_elevation_forFilterRoutes = null;
    let chart_canvas_speed_elevation_forFilterRoutes_curRouteIndex = -1;
    function func_update_chart_canvas_speed_elevation_forFilterRoutes(demo_singleRoute)
    {
        var data_normalized = []

        for (var i = 0; i < demo_singleRoute.length; i++) {
            data_normalized.push([demo_singleRoute[i]['latitude'], demo_singleRoute[i]['longitude']]);
        }

        function makeYData_elevation() {
            var result = []
            for (var i = 0; i < demo_singleRoute.length; i++) {
                result.push(demo_singleRoute[i]['elevation'] / 1000)
            }
            return result;
        }
        var dataY_elevation = makeYData_elevation();
        //draw in plot

        function makeYData_speed() {
            var result = []
            for (var i = 0; i < demo_singleRoute.length; i++) {
                result.push(demo_singleRoute[i]['speed'] * 60 / 1000);
            }
            return result;
        }
        var dataY_speed = makeYData_speed();
        // console.log(dataY_elevation,dataY_speed);
        var data_x = [];
        for (var i = 0; i < demo_singleRoute.length; i++) {
                data_x.push(demo_singleRoute[i]['time']);
        }

        chart_canvas_speed_elevation_forFilterRoutes.updateSeries([
                    {
                        name: '速度(km/min)',
                        data: dataY_speed,
                    },
                    {
                        name: '海拔(km)',
                        data: dataY_elevation,
                    },
        ]);

        chart_canvas_speed_elevation_forFilterRoutes.updateOptions({
            xaxis: {
                    type: 'category',
                    categories: data_x,
            }
        });
    }


    request_askRoutesData()
    function request_askRoutesData() {
      function reqListener() {
        // console.log(typeof (this.responseText), typeof (this.response));
        // console.log(this.responseText)

        var response = JSON.parse(this.responseText);
        for(var i=0;i<routeId_list.length;i++)
        {
          routeId = routeId_list[i];
          var route = response[routeId];
          for(var j=0;j<route.length;j++)
          {
            route[j]['time'] = (new Date(route[j]['time']+' UTC')).toLocaleString('zh-TW',{hour12: false});
          }
          routes_origin.push(route);
          var summary = response[routeId+'pigeonNumber'];
          console.log('summary',summary);
          var cur_pigeonNumber_releaseTime = {'pigeonNumber':summary['recordname'],'release_time':summary['settingtime'],'real_distance':summary['realdistance'],'speed':summary['realspeed'],'straightdistance':summary['straightdistance'],'straightspeed':summary['straightspeed']};
          cur_pigeonNumber_releaseTime['routeEfficiency'] = parseFloat(cur_pigeonNumber_releaseTime['straightdistance'])/parseFloat(cur_pigeonNumber_releaseTime['real_distance']);
          pigeonNumbers_releaseTime.push(cur_pigeonNumber_releaseTime);
        //   console.log(pigeonNumbers_releaseTime);

          map_pigeonNumberReleaseTime_routeIndex.push({'pigeonNumber':summary['recordname'],'release_time':summary['settingtime'],'index':routes_origin.length-1});
          console.log('map_pigeonNumberReleaseTime_routeIndex',map_pigeonNumberReleaseTime_routeIndex);
          map_routeIndex_pigeonNumberReleaseTime[routes_origin.length-1] = cur_pigeonNumber_releaseTime;
        }
        tracks_showInTable(pigeonNumbers_releaseTime)
        show_figures(routes_origin);

        // var routes =  Object.values(response);
        // // console.log(Object.values(response));
        // console.log(routes);
        // tracks_showInTable(routeId_list)
        // show_figures(routes);
      }

      var oReq = new XMLHttpRequest();
      oReq.addEventListener("load", reqListener);
      oReq.open("post", 'figures/askTracksData');
      oReq.setRequestHeader("X-CSRFToken", '{{ csrf_token|safe }}');
      // oReq.setRequestHeader("Content-Type", "text/plain;charset=UTF-8");   
      oReq.send(routeId_list.toString());
    }

    function tracks_showInTable(pigeonReleaseTime_list) {
            let table_pigeonNumber_body = document.getElementById('table_pigeonNumber_body');
            for (var i = 0; i < pigeonReleaseTime_list.length; i++) {
                func_table_track_addData(pigeonReleaseTime_list[i]);
            }
            function func_table_track_addData(pigeonNumGps) {
                var row = document.createElement('tr');
                var row_data_0 = document.createElement("INPUT");
                row_data_0.setAttribute("type", "checkbox");
                // row_data_0.setAttribute('id','table_pigeonNumber_body_checkbox');
                function func_cb_checbox()
                {
                    // console.log('click');
                    //todo
                    //1 if checked show path in map ,not remove from map
                    //2 if checked show path in speed_elevation_plot ,not remove from map
                    if(row_data_0.checked)
                    {
                        var pigeonNumber = row_data_1.innerHTML;
                        var release_time = row_data_2.innerHTML;
                        console.log(pigeonNumber,release_time,release_time.length,typeof(release_time));
                        for(var i_lineObject=0;i_lineObject<lineObjects_in_Map_showPaths.length;i_lineObject++)
                        {
                           if(lineObjects_in_Map_showPaths[i_lineObject]['pigeonNumber']==pigeonNumber&&lineObjects_in_Map_showPaths[i_lineObject]['releaseTime']== release_time)
                            {
                                console.log('remove polyline');
                                map_handler.addLayer(lineObjects_in_Map_showPaths[i_lineObject]['object']);
                                // windy_map_handler.addLayer(lineObjects_in_windy[i_lineObject]['object']);
                            }
                        }
                    }
                    else
                    {
                        var pigeonNumber = row_data_1.innerHTML;
                        var release_time = row_data_2.innerHTML;
                        console.log(pigeonNumber,release_time,release_time.length,typeof(release_time));
                        for(var i_lineObject=0;i_lineObject<lineObjects_in_Map_showPaths.length;i_lineObject++)
                        {
                           if(lineObjects_in_Map_showPaths[i_lineObject]['pigeonNumber']==pigeonNumber&&lineObjects_in_Map_showPaths[i_lineObject]['releaseTime']== release_time)
                            {
                                console.log('remove polyline');
                                map_handler.removeLayer(lineObjects_in_Map_showPaths[i_lineObject]['object']);
                                // windy_map_handler.removeLayer(lineObjects_in_windy[i_lineObject]['object']);
                            }
                        }
                    }
                }
                row_data_0.checked = true;
                row_data_0.addEventListener('click',func_cb_checbox);
                // row_data_0.style.position = 'absolute';
                // row_data_0.style.top = '30%';
                var row_data_1 = document.createElement('td');
                row_data_1.innerHTML = pigeonNumGps['pigeonNumber'];
                row_data_1.style.textAlign = "center";
                var row_data_2 = document.createElement('td');
                row_data_2.innerHTML = pigeonNumGps['release_time'];
                row_data_2.style.textAlign = "center";
                var row_data_3 = document.createElement('td');
                row_data_3.innerHTML = pigeonNumGps['real_distance'].toFixed(3);
                row_data_3.style.textAlign = "center";
                var row_data_4 = document.createElement('td');
                row_data_4.innerHTML = pigeonNumGps['speed'].toFixed(3);
                row_data_4.style.textAlign = "center";
                var row_data_5 = document.createElement('td');
                row_data_5.innerHTML = pigeonNumGps['straightdistance'].toFixed(3);
                row_data_5.style.textAlign = "center";
                var row_data_6 = document.createElement('td');
                row_data_6.innerHTML = pigeonNumGps['straightspeed'].toFixed(3);
                row_data_6.style.textAlign = "center";
                var row_data_7 = document.createElement('td');
                row_data_7.innerHTML = pigeonNumGps['routeEfficiency'].toFixed(3);
                row_data_7.style.textAlign = "center";
                var row_data_8 = document.createElement('td');
                row_data_8.innerHTML = '未';
                row_data_8.style.textAlign = "center";

                row.appendChild(row_data_0);
                row.appendChild(row_data_1);
                row.appendChild(row_data_2);
                row.appendChild(row_data_3);
                row.appendChild(row_data_4);
                row.appendChild(row_data_5);
                row.appendChild(row_data_6);
                row.appendChild(row_data_7);
                row.appendChild(row_data_8);

                function func_cb_row()
                {
                    console.log('click');
                    //todo
                    //1 if checked show path in map ,not remove from map
                    //2 if checked show path in speed_elevation_plot ,not remove from map

                    var pigeonNumber = row_data_1.innerHTML;
                    var release_time = row_data_2.innerHTML;
                    
                    var route_index = -1;
                    for(var i=0;i<map_pigeonNumberReleaseTime_routeIndex.length;i++)
                    {
                        if(map_pigeonNumberReleaseTime_routeIndex[i]['pigeonNumber']==pigeonNumber&&map_pigeonNumberReleaseTime_routeIndex[i]['release_time']==release_time)
                        {
                            route_index=map_pigeonNumberReleaseTime_routeIndex[i]['index'];
                        }
                    }
                    if(route_index>=0)
                    {
                        // console.log(routes_origin[route_index]);
                        func_update_chart_canvas_speed_elevation_forFilterRoutes(routes_origin[route_index]);
                        chart_canvas_speed_elevation_forFilterRoutes_curRouteIndex = route_index;
                    }
                    console.log(pigeonNumber,release_time,route_index);
                //    
                }
                row.addEventListener('dblclick',func_cb_row);
                table_pigeonNumber_body.appendChild(row);
            }
    }

    function table_pigeonNumber_body_updateByFilteredRoute(routeIndex,filted_route)
    {
        var real_distance = 0;
        for(var i=0;i<filted_route.length;i++)
        {
            real_distance+=parseFloat(filted_route[i]['distance']);
        }
        console.log('real_distance',real_distance);

        var startPoint = [filted_route[0]['longitude'],filted_route[0]['latitude']];
        var endPoint = [filted_route[filted_route.length-1]['longitude'],filted_route[filted_route.length-1]['latitude']];
        var from = turf.point(startPoint);
        var to = turf.point(endPoint);
        var options = {units: 'kilometers'};
        var straightdistance = turf.distance(from, to, options)*1000;

        var routeEfficiency = straightdistance/real_distance;
        console.log('routeEfficiency',routeEfficiency);

        var start_time = new Date(filted_route[0]['time']);
        var end_time = new Date(filted_route[filted_route.length-1]['time']);
        
        console.log(start_time,end_time);
        var elapsed = (end_time.getTime() - start_time.getTime())/1000;
        
        var speed = real_distance/(elapsed/60);
        console.log('speed',speed);

        var straightspeed = straightdistance/(elapsed/60);

        var rows = document.getElementById("table_pigeonNumber_body").rows;
        console.log(rows);
        var td_realditance = rows[routeIndex].getElementsByTagName("td")[2];
        var td_speed = rows[routeIndex].getElementsByTagName("td")[3];
        var td_straightdistance = rows[routeIndex].getElementsByTagName("td")[4];
        var td_straightspeed = rows[routeIndex].getElementsByTagName("td")[5];
        var td_routeEfficiency = rows[routeIndex].getElementsByTagName("td")[6];
        var td_filter = rows[routeIndex].getElementsByTagName("td")[7];
            
        td_realditance.innerHTML = real_distance.toFixed(3);
        td_speed.innerHTML = speed.toFixed(3);
        td_straightdistance.innerHTML = straightdistance.toFixed(3);
        td_straightspeed.innerHTML = straightspeed.toFixed(3);
        td_routeEfficiency.innerHTML = routeEfficiency.toFixed(3);
        td_filter.innerHTML = '是';
    }

    function show_figures(test_demo_data)
    {
        console.log(test_demo_data.length);
        ///set source data
        const demo_singleRoute = test_demo_data[0];
        console.log(demo_singleRoute.length);
        // for(var i=0;i<demo_singleRoute.length;i++)
        // {
        //     console.log('time',demo_singleRoute[i]['time']);
        // }

        function showInMap(path,pigeonNumber,release_time,filtered_route =false) {

            var path_normalize = [];
            for (var i = 0; i < path.length; i++) {
                var cell = [];
                cell.push(parseFloat(path[i]['latitude']));
                cell.push(parseFloat(path[i]['longitude']));
                path_normalize.push(cell);
            }
            console.log(path_normalize);

            map_handler.setView(path_normalize[0], 10);
            var baseLine = [path_normalize[0], path_normalize[path_normalize.length - 1]];
            // console.log(baseLine.length);
            // L.polyline(baseLine, { color: 'blue', weight: '1' }).addTo(map_handler);

            if(filtered_route)
            {
                var lineObject = drawPath(path_normalize,'blue','3');
                lineObjects_in_Map_showPaths.push({'pigeonNumber':pigeonNumber,'releaseTime':release_time,'filtered':'true','object':lineObject});
            }
            else
            {
                var lineObject =drawPath(path_normalize,'red','1');
                lineObjects_in_Map_showPaths.push({'pigeonNumber':pigeonNumber,'releaseTime':release_time,'filtered':'false','object':lineObject});
            }
            
            function drawPath(pathLine_origin,color,weight) {
                console.log(typeof (pathLine_origin));
                // console.log(pathLine_origin);
                var pathLine_origin_normalized = pathLine_origin;
                // console.log(typeof (pathLine_origin_normalized));
                // console.log(pathLine_origin_normalized);

                var polyline_origin = L.polyline(pathLine_origin_normalized, { color: color, weight: weight }).addTo(map_handler);
                // var polyline_filtered = L.polyline(pathLine_filter_normalized, { color: 'yellow' }).addTo(map_handler);
                // var polygon = L.polygon(pathPolygon_normalized).addTo(map_handler);
                return polyline_origin;
            }
        }

        // var button_showPaths = document.getElementById('button_windy_showPath');
        // button_showPaths.addEventListener('click',function(){
        //     showInMap_multi_init(test_demo_data);
        // });

        showInMap_multi_init(test_demo_data);
        function showInMap_multi_init(paths) {

            var path_normalize_list = [];
            for( var i=0;i<paths.length;i++)
            {
                var path = paths[i];
                var path_normalize=[];
                for (var j = 0; j < path.length; j++) {
                    var cell = [];
                    cell.push(parseFloat(path[j]['latitude']));
                    cell.push(parseFloat(path[j]['longitude']));
                    path_normalize.push(cell);
                }
                path_normalize_list.push(path_normalize);
            }

            console.log(path_normalize_list);

            map_handler.setView(path_normalize_list[0][0], 10);

            var color_list_routes = [];
            for(var i=0;i<path_normalize_list.length;i++)
            {
                var color  = getRandomColor();
                color_list_routes.push(color);
                // var lineObject = drawPath(path_normalize_list[i],'red','3');
                var lineObject = drawPath(path_normalize_list[i],color,'3');
                var pigeonNumber_releaseTime = map_routeIndex_pigeonNumberReleaseTime[i];
                console.log('pigeonNumber_releaseTime',pigeonNumber_releaseTime);
                console.log(pigeonNumber_releaseTime['pigeonNumber']);
                lineObjects_in_Map_showPaths.push({'pigeonNumber':pigeonNumber_releaseTime['pigeonNumber'],'releaseTime':pigeonNumber_releaseTime['release_time'],'filtered':false,'object':lineObject});
                console.log('lineObjects_in_Map_showPaths',lineObjects_in_Map_showPaths);
            }
            
            function drawPath(pathLine_origin,color,weight) {
                console.log(typeof (pathLine_origin));
                // console.log(pathLine_origin);
                var pathLine_origin_normalized = pathLine_origin;
                // console.log(typeof (pathLine_origin_normalized));
                // console.log(pathLine_origin_normalized);

                var polyline_origin = L.polyline(pathLine_origin_normalized, { color: color, weight: weight }).addTo(map_handler);
                // var polyline_filtered = L.polyline(pathLine_filter_normalized, { color: 'yellow' }).addTo(map_handler);
                // var polygon = L.polygon(pathPolygon_normalized).addTo(map_handler);
                return polyline_origin;
            }

            function drawPath_windy(pathLine_origin,color,weight) {
                console.log(typeof (pathLine_origin));
                // console.log(pathLine_origin);
                var pathLine_origin_normalized = pathLine_origin;
                // console.log(typeof (pathLine_origin_normalized));
                // console.log(pathLine_origin_normalized);

                var polyline_origin = map_layer_windy.polyline(pathLine_origin_normalized, { color: color, weight: weight }).addTo(map_handler);
                // var polyline_filtered = L.polyline(pathLine_filter_normalized, { color: 'yellow' }).addTo(map_handler);
                // var polygon = L.polygon(pathPolygon_normalized).addTo(map_handler);
                return polyline_origin;
            }

            windy_movingPoint = map_layer_windy.circle([0, 0], { radius: 1600 ,color:'blue'}).addTo(map_handler);
        }

        function showInMap_movepoint(point) {
            windy_movingPoint.setLatLng(L.latLng(point['latitude'], point['longitude']));
            var zoomLevel = map_handler.getZoom();
            // console.log(zoomLevel);
            if((zoomLevel-10)>0)
            {
                windy_movingPoint.setRadius(300/(zoomLevel-10));
            }
            map_handler.setView(point);
        }

        class Route_Filter
        {
          constructor() { 
            this.filter_start = false;
            this.filter_end = false;
            this.route_index = -1;
            this.startIndex = -1;

            //save only filtered_route for each route
            this.filtered_routes = {};
          }

          getStatus_filter()
          {
            return this.filter_start;
          }

          start_filter(index_inDemoRoutes,index_startToFilter)
          {
            if(index_inDemoRoutes>=0&&index_inDemoRoutes<test_demo_data.length)
            {
              if(index_startToFilter>=0&&index_startToFilter<test_demo_data[index_inDemoRoutes].length)
              {
                this.filter_start=true;
                this.route_index = index_inDemoRoutes;
                this.startIndex = index_startToFilter;

                
                return true;
              }
            }
            return false;
          }
          endFilter_GetFilteredRoutes(index_endFilter)
          {
            if(this.filter_start == true)
            {
              if(index_endFilter>=this.startIndex&&index_endFilter<test_demo_data[this.route_index].length)
              {
                {
                  this.filter_start = false;
                  var filted_route = test_demo_data[this.route_index].slice(this.startIndex,index_endFilter);

                  this.filtered_routes[this.route_index]= filted_route;
                  return filted_route;
                //   return test_demo_data[this.route_index].slice(this.startIndex,index_endFilter);
                }
              }
            }
          }
        }

        let route_filter_handler = new Route_Filter();
            //show figures 
        let button_showFigures_FilteredRoutes = document.getElementById('button_showFigures_FilteredRoutes');
        function func_cb_button_showFigures_FilteredRoutes()
        {
            //show figures by filtered routes
            var pigeonNumbers =[];
            var release_time_list = [];
            var filtered_route_list =[];
            for (const [routeIndex, filtered_route] of Object.entries(route_filter_handler.filtered_routes)) {
                var pigeonNumber = map_routeIndex_pigeonNumberReleaseTime[routeIndex]['pigeonNumber'];
                var ReleaseTime = map_routeIndex_pigeonNumberReleaseTime[routeIndex]['release_time'];

                pigeonNumbers.push(pigeonNumber);
                release_time_list.push(ReleaseTime);
                filtered_route_list.push(filtered_route);
            }
            //todo:show in figures
            show_figures_byFilteredRoutes_soloPigeon_routeEffProcess(pigeonNumbers,release_time_list,filtered_route_list);
            // show_figures_byFilteredRoutes_distancefrombeeline_realtime_boxplot(pigeonNumbers,release_time_list,filtered_route_list);
            show_figures_byFilteredRoutes_multiRoutes_routeSimilarity(pigeonNumbers,release_time_list,filtered_route_list);
        }
        button_showFigures_FilteredRoutes.addEventListener('click',func_cb_button_showFigures_FilteredRoutes);

        func_solo_route_SpeedElevation(test_demo_data[0]);
        ///functions for solo route's figures analysis
        function func_solo_route_SpeedElevation(demo_singleRoute) {
            var data_normalized = []

            for (var i = 0; i < demo_singleRoute.length; i++) {
                data_normalized.push([demo_singleRoute[i]['latitude'], demo_singleRoute[i]['longitude']]);
            }

            function makeYData_elevation() {
                var result = []
                for (var i = 0; i < demo_singleRoute.length; i++) {
                    result.push(demo_singleRoute[i]['elevation'] / 1000)
                }
                return result;
            }
            var dataY_elevation = makeYData_elevation();
            //draw in plot

            function makeYData_speed() {
                var result = []
                for (var i = 0; i < demo_singleRoute.length; i++) {
                    result.push(demo_singleRoute[i]['speed'] * 60 / 1000);
                }
                return result;
            }
            var dataY_speed = makeYData_speed();

            function makeYData_elevation() {
                var result = []
                for (var i = 0; i < demo_singleRoute.length; i++) {
                    result.push(demo_singleRoute[i]['elevation'] / 1000)
                }
                return result;
            }
            var dataY_elevation = makeYData_elevation();

            var data_x = [];
            for (var i = 0; i < demo_singleRoute.length; i++) {
                data_x.push(demo_singleRoute[i]['time']);
            }
            // console.log(data_x);

            //set options
            var options = {
                series: [
                    {
                        name: '速度(km/min)',
                        data: dataY_speed,
                    },
                    {
                        name: '海拔(km)',
                        data: dataY_elevation,
                    },
                ],
                chart: {
                    height: 350,
                    type: 'line',
                    zoom: {
                        enabled: false
                    },
                    events: {
                      mouseMove: function (event, chartContext, config) {
                          try {
                              showInMap_movepoint(test_demo_data[chart_canvas_speed_elevation_forFilterRoutes_curRouteIndex][config['dataPointIndex']]);
                              windy_map_movePoint(test_demo_data[chart_canvas_speed_elevation_forFilterRoutes_curRouteIndex][config['dataPointIndex']]);  
                          } catch (e) {
                              console.log(e); // Error: hi
                          }
                      },
                      click: function(event, chartContext, config) {
                      // The last parameter config contains additional information like `seriesIndex` and `dataPointIndex` for cartesian charts
                        try {
                              if(route_filter_handler.getStatus_filter() == false)
                              {
                                console.log(config['dataPointIndex']);
                                if(route_filter_handler.start_filter(chart_canvas_speed_elevation_forFilterRoutes_curRouteIndex, config['dataPointIndex']))
                                {
                                    var label_filter = document.getElementById('label_solo_route_SpeedElevation');
                                    label_filter.innerHTML = '裁減中，請點擊右側終點以完成裁減';
                                }
                              }
                              else
                              {
                                var filtered_route =  route_filter_handler.endFilter_GetFilteredRoutes(config['dataPointIndex']);
                                var cur_routeIndex = chart_canvas_speed_elevation_forFilterRoutes_curRouteIndex;
                                var pigeonNumber = map_routeIndex_pigeonNumberReleaseTime[cur_routeIndex]['pigeonNumber'];
                                var release_time = map_routeIndex_pigeonNumberReleaseTime[cur_routeIndex]['release_time'];
                                // showInMap(filtered_route,pigeonNumber,release_time,true);
 
                                var label_filter = document.getElementById('label_solo_route_SpeedElevation');
                                label_filter.innerHTML = '裁減：點擊圖表進行裁減';

                                table_pigeonNumber_body_updateByFilteredRoute(cur_routeIndex,filtered_route);
                              }
                            } catch (e) {
                                console.log(e); // Error: hi
                            }
                    }
                  },
                },
                colors: ['#77B6EA', '#545454', '#7CFC00', '#b84644', '#4576b5'],
                dataLabels: {
                    enabled: false
                },
                stroke: {
                    curve: 'straight'
                },
                title: {
                    text: '速度.海拔的對比圖',
                    align: 'left'
                },
                grid: {
                    row: {
                        colors: ['#f3f3f3', 'transparent'], // takes an array which will be repeated on columns
                        opacity: 0.5
                    },
                },
                legend: {
                    position: 'top',
                    horizontalAlign: 'right',
                    floating: true,
                    offsetY: -25,
                    offsetX: -5
                },
                xaxis: {
                    type: 'category',
                    categories: data_x,
                }
            };

            chart_canvas_speed_elevation_forFilterRoutes = new ApexCharts(canvas_speed_elevation_forFilterRoutes, options);
            chart_canvas_speed_elevation_forFilterRoutes.render();
            chart_canvas_speed_elevation_forFilterRoutes_curRouteIndex = 0;


            function draw_earthElevation(elevations) {
                var normalized_elevations = [];
                for (var i = 0; i < elevations.length; i++) {
                    normalized_elevations.push(elevations[i] / 1000);
                }
                var make_data = {
                    name: '地面海拔(km)',
                    data: normalized_elevations,
                }
                // console.log(chart);
                chart_canvas_speed_elevation_forFilterRoutes.opts.series.push(make_data);
                // chart.opts.colors.push();
                chart_canvas_speed_elevation_forFilterRoutes.update();
            }

            function draw_elevationFromEarth(elevations) {
                var normalized_elevations = [];
                for (var i = 0; i < elevations.length; i++) {
                    normalized_elevations.push(dataY_elevation[i] - elevations[i] / 1000);
                }
                var make_data = {
                    type: 'line',
                    label: '離地高度(km)',
                    data: normalized_elevations,
                    // backgroundColor: 'transparent',
                    fill: false,
                    borderColor: 'green',
                }
                myChart_RoutePlot.data.datasets.push(make_data);
                myChart_RoutePlot.update();
            }

            makeYData_earthElevation();

            function makeYData_earthElevation() {
                var result = [];
                var dataToSend = "";
                var dataToSend_json = [];
                for (var i_earthEle = 0; i_earthEle < data_normalized.length; i_earthEle++) {
                    var lat = data_normalized[i_earthEle][0];
                    var lon = data_normalized[i_earthEle][1];

                    dataToSend_json.push({ "latitude":  parseFloat(lat) , "longitude": parseFloat(lon) });
                }

                const url = 'https://api.open-elevation.com/api/v1/lookup?';
                var oReq = new XMLHttpRequest();

                function reqListener() {
                    // console.log(typeof (this.responseText), typeof (this.response));
                    // console.log(this);

                    var response = JSON.parse(this.responseText);
                    console.log(response.results);
                    for (var i_res = 0; i_res < response.results.length; i_res++) {
                        result.push(response.results[i_res]['elevation']);
                    }
                    console.log(result);
                    //todo draw in chart
                    draw_earthElevation(result);
                    // draw_elevationFromEarth(result);
                }

                oReq.addEventListener("load", reqListener);
                oReq.open("post", url,true);
                oReq.setRequestHeader("Accept", "application/json");
                oReq.setRequestHeader("Content-Type", "application/json");
                console.log(oReq);
                oReq.send(JSON.stringify({ "locations": dataToSend_json }));
            }

        }
    }
    
    function show_figures_byFilteredRoutes_soloPigeon_routeEffProcess(pigeonNumbers,release_time_list,test_demo_data)
    {
    //   var pre_label = document.getElementById('label_soloPigeon_routeEffProcess');
    //   if(pre_label)
    //   {
    //     pre_label.remove();
    //   }
      func_label_soloPigeon_routeEff_process();
      //draw a label for route accuracy
      function func_label_soloPigeon_routeEff_process() {

        var label = document.getElementById('label_routeEff_Polyline_plot');
        var dialog = document.getElementById('dialog_routeEfficiency');
        label.addEventListener('click', () => {
              if (typeof dialog.showModal === "function") {
                  dialog.showModal();
              } else {
                  alert("Sorry, the <dialog> API is not supported by this browser.");
              }
          });
      }

      func_multiRoutes_routeEff_process();

      function func_multiRoutes_routeEff_process() {    
        //   var pre_canvas = document.getElementById('canvas_routeEff_Polyline_plot');
        //   if(pre_canvas)
        //   {
        //     pre_canvas.remove();
        //   }
          //normalize routes
          var normalized_multiroutes = [];
          for (var i = 0; i < test_demo_data.length; i++) {
              var normalized_route = [];
              for (var j = 0; j < test_demo_data[i].length; j++) {
                  normalized_route.push([test_demo_data[i][j]['latitude'], test_demo_data[i][j]['longitude']]);
              }
              normalized_multiroutes.push(normalized_route);
          }
        //   console.log(normalized_multiroutes);

          //calculate route effs
          var routes_effs = [];
          for (var i = 0; i < normalized_multiroutes.length; i++) {
              var cur_route = normalized_multiroutes[i];
              var start_point = turf.point([cur_route[0][1],cur_route[0][0]]);
              var end_Point = turf.point([cur_route[cur_route.length - 1][1],cur_route[cur_route.length - 1][0]]);
              var baselineDistance = turf.distance(start_point, end_Point, { units: 'kilometers' }) * 1000;

              var realDistance = 0;
              var realDistance_turf = 0;
              for (var j = 0; j < cur_route.length-1; j++) {
                // console.log(test_demo_data[i][j]['distance']);
                realDistance += parseFloat(test_demo_data[i][j]['distance']);

                var start_point = turf.point([cur_route[j][1],cur_route[j][0]]);
                var end_Point =turf.point([cur_route[j+1][1],cur_route[j+1][0]]);
                // console.log(turf.distance(start_point, end_Point, { units: 'kilometers' }) * 1000);
                realDistance_turf += turf.distance(start_point, end_Point, { units: 'kilometers' }) * 1000;
              }
              console.log(cur_route[0],cur_route[cur_route.length - 1],baselineDistance,realDistance,realDistance_turf);
              var routeEff = baselineDistance / realDistance_turf;
            //   var routeEff = baselineDistance / realDistance;
              routes_effs.push(routeEff.toFixed(3));
          }

          var data_x = [];
          for (var i = 0; i < pigeonNumbers.length; i++) {
            //   console.log(pigeonNumbers[i],release_time_list[i]);
              data_x.push(pigeonNumbers[i]+' '+release_time_list[i]);
          }
          console.log(data_x);

          var make_data = [];
          for(var i=0;i<routes_effs.length;i++)
          {
            make_data.push([data_x[i],routes_effs[i]]);
          }
          console.log(make_data);

          var realspeed_list = [];
          var straightspeed_list =[];
          for(var i=0;i<test_demo_data.length;i++)
          {
            var speed = make_realspeed(test_demo_data[i]);
            realspeed_list.push(speed.toFixed(3));
            straightspeed_list.push((make_straightspeed(test_demo_data[i])).toFixed(3));
          }
          console.log('realspeed_list',realspeed_list);
          function make_realspeed(filted_route)
          {
                var real_distance = 0;
                for(var i=0;i<filted_route.length;i++)
                {
                    real_distance+=parseFloat(filted_route[i]['distance']);
                }
                console.log('real_distance',real_distance);

                // var startPoint = [filted_route[0]['longitude'],filted_route[0]['latitude']];
                // var endPoint = [filted_route[filted_route.length-1]['longitude'],filted_route[filted_route.length-1]['latitude']];
                // var from = turf.point(startPoint);
                // var to = turf.point(endPoint);
                // var options = {units: 'kilometers'};
                // var straightdistance = turf.distance(from, to, options)*1000;

                // var routeEfficiency = straightdistance/real_distance;
                // console.log('routeEfficiency',routeEfficiency);

                var start_time = new Date(filted_route[0]['time']);
                var end_time = new Date(filted_route[filted_route.length-1]['time']);
                
                // console.log(start_time,end_time);
                var elapsed = (end_time.getTime() - start_time.getTime())/1000;
                
                var speed = real_distance/(elapsed/60);
                // console.log('speed',speed);
                return speed;

                // var straightspeed = straightdistance/(elapsed/60);
          }

          function make_straightspeed(filted_route)
          {
                // var real_distance = 0;
                // for(var i=0;i<filted_route.length;i++)
                // {
                //     real_distance+=parseFloat(filted_route[i]['distance']);
                // }
                // console.log('real_distance',real_distance);

                var startPoint = [filted_route[0]['longitude'],filted_route[0]['latitude']];
                var endPoint = [filted_route[filted_route.length-1]['longitude'],filted_route[filted_route.length-1]['latitude']];
                var from = turf.point(startPoint);
                var to = turf.point(endPoint);
                var options = {units: 'kilometers'};
                var straightdistance = turf.distance(from, to, options)*1000;

                var start_time = new Date(filted_route[0]['time']);
                var end_time = new Date(filted_route[filted_route.length-1]['time']);
                
                // console.log(start_time,end_time);
                var elapsed = (end_time.getTime() - start_time.getTime())/1000;

                var straightspeed = straightdistance/(elapsed/60);
                return straightspeed;
          }


          draw_line_routeEffs();

          function draw_line_routeEffs() {
              var options = {
                  series: [{
                      name: "路徑效率",
                      type: 'column',
                      data: routes_effs
                    // data:make_data
                  },
                  {
                    name: '實際分速',
                    type: 'line',
                    data:  realspeed_list
                  },
                  {
                    name: '直線分速',
                    type: 'line',
                    data:  straightspeed_list
                  }
                ],
                  chart: {
                      height: 400,
                      type: 'line',
                      zoom: {
                          enabled: false
                      }
                  },
                //   dataLabels: {
                //       enabled: false
                //   },
                  dataLabels: {
                    enabled: true,
                    enabledOnSeries: [1,2]
                  },
                  labels: data_x,
                  stroke: {
                      width: [0, 4,4]
                  },
                //   title: {
                //       text: '路徑效率process圖:路徑效率/放飛時間',
                //       align: 'middle'
                //   },
                //   grid: {
                //       row: {
                //           colors: ['#f3f3f3', 'transparent'], // takes an array which will be repeated on columns
                //           opacity: 0.5
                //       },
                //   },
                  xaxis: {
                    type: 'category',
                    // categories: data_x,
                  },
                  yaxis: [{
                    title: {
                        text: '路徑效率',
                    },
                    
                    }, {
                    opposite: true,
                    title: {
                        text: '實際分速(m/min),直線分速(m/min)'
                    }
                }]
              };

            var canvas_routeEff_Polyline_plot = document.getElementById('canvas_routeEff_Polyline_plot');
            var chart = new ApexCharts(canvas_routeEff_Polyline_plot, options);
            chart.render();
          }

      }
    }

    function show_figures_byFilteredRoutes_distancefrombeeline_realtime_boxplot(pigeonNumbers,release_time_list,test_demo_data)
    {

      func_label_distancefrombeeline_realtime_boxplot();
      //draw a label for route accuracy
      function func_label_distancefrombeeline_realtime_boxplot() {

        var label = document.getElementById('label_distancefrombeeline_realtime_boxplot');
        var dialog = document.getElementById('dialog_routeEfficiency');
        label.addEventListener('click', () => {
              if (typeof dialog.showModal === "function") {
                  dialog.showModal();
              } else {
                  alert("Sorry, the <dialog> API is not supported by this browser.");
              }
          });
      }

      func_multiRoutes_distancefrombeeline_realtime_boxplot();

      function func_multiRoutes_distancefrombeeline_realtime_boxplot() {    
          var normalized_multiroutes = [];
          for (var i = 0; i < test_demo_data.length; i++) {
              var normalized_route = [];
              for (var j = 0; j < test_demo_data[i].length; j++) {
                //   normalized_route.push([test_demo_data[i][j]['latitude'], test_demo_data[i][j]['longitude']]);
                normalized_route.push([test_demo_data[i][j]['longitude'], test_demo_data[i][j]['latitude']]);
              }
              normalized_multiroutes.push(normalized_route);
          }
          console.log(normalized_multiroutes);

          //calculate route effs
          var routeEff_list_realtime_multi = [];
          for (var i = 0; i < normalized_multiroutes.length; i++) {

            var cur_route = normalized_multiroutes[i];
            var baseLine = turf.lineString([cur_route[0], cur_route[cur_route.length - 1]]);
            // console.log(cur_route.join());
            var routeEff_list_realtime = [];
            var total_distance = 0;
            for (var j = 0; j < cur_route.length; j++) {
                var pt = turf.point(cur_route[j]);
                // console.log(cur_route[j]);
                //distance to baseline
                var distanceToLine = turf.pointToLineDistance(pt, baseLine, {units: 'kilometers'});
                console.log(j,cur_route[j],distanceToLine);
                routeEff_list_realtime.push(distanceToLine.toFixed(3));
            }
            routeEff_list_realtime_multi.push(routeEff_list_realtime);
          }
          console.log(routeEff_list_realtime_multi);

          var data_x = [];
          for (var i = 0; i < pigeonNumbers.length; i++) {
            //   console.log(pigeonNumbers[i],release_time_list[i]);
              data_x.push(pigeonNumbers[i]+' '+release_time_list[i]);
          }
          console.log(data_x);


        func_draw_boxplot();

        function func_draw_boxplot() {
            //set options
            var options = {
                series: [{
                    name: 'box',
                    type: 'boxPlot',
                    data: [
                    ]
                },],
                chart: {
                    type: 'boxPlot',
                    height: 350,
                },
                colors: ['#008FFB', '#FEB019'],
                title: {
                    text: '平均路徑距離',
                    align: 'middle'
                },
                tooltip: {
                    shared: false,
                    intersect: true
                },
                yaxis: {
                    // min: 0,
                    // max: 1000,
                    type: 'numeric',
                }
            }; 

            //sort distances
            var routeEff_list_realtime_multi_sorted = [];
            for (var i = 0; i < routeEff_list_realtime_multi.length; i++) {
                routeEff_list_realtime_multi_sorted.push(routeEff_list_realtime_multi[i].sort(function (a, b) { return a - b }));
            }
            console.log(routeEff_list_realtime_multi_sorted);

            for (var i = 0; i < routeEff_list_realtime_multi_sorted.length; i++) {
                var data = routeEff_list_realtime_multi_sorted[i];
                var min = data[0];
                var q1 = data[Math.floor(data.length / 4)];
                var median = data[Math.floor(data.length / 2)];
                var q3 = data[Math.floor(data.length * 3 / 4)];
                var max = data[data.length - 1];

                options.series[0].data.push({ 'x': i, 'y': [min, q1, median, q3, max] });
            }
            console.log(options.series[0].data);
            var canvas_distancefrombeeline_realtime_boxplot = document.getElementById('canvas_distancefrombeeline_realtime_boxplot');
            var chart = new ApexCharts(canvas_distancefrombeeline_realtime_boxplot, options);

            chart.render();
        }
      }
    }

    function show_figures_byFilteredRoutes_multiRoutes_routeSimilarity(pigeonNumbers,release_time_list,test_demo_data)
    {

      func_label_multiRoutes_routeSimilarity();
      //draw a label for route accuracy
      function func_label_multiRoutes_routeSimilarity() {

        var label = document.getElementById('label_multiRoutes_routeSimilarity');
        var dialog = document.getElementById('dialog_routeSimilarity');
        label.addEventListener('click', () => {
              if (typeof dialog.showModal === "function") {
                  dialog.showModal();
              } else {
                  alert("Sorry, the <dialog> API is not supported by this browser.");
              }
          });
      }

      func_multiRoutes_routeSimilarity();

      function func_multiRoutes_routeSimilarity() {    
          var normalized_multiroutes = [];
          for (var i = 0; i < test_demo_data.length; i++) {
              var normalized_route = [];
              for (var j = 0; j < test_demo_data[i].length; j++) {
                  normalized_route.push([test_demo_data[i][j]['latitude'], test_demo_data[i][j]['longitude']]);
              }
              normalized_multiroutes.push(normalized_route);
          }
          console.log(normalized_multiroutes);

          var distance_point_toBaseLine_multi = [];
          for (var i = 0; i < normalized_multiroutes.length-1; i++) {
            var base_route = normalized_multiroutes[i];
            var cur_route = normalized_multiroutes[i+1];
            var baseLine = turf.lineString(base_route);
            // console.log(cur_route.join());
            var distance_point_toBaseLine = [];
            for (var j = 0; j < cur_route.length; j++) {
                var pt = turf.point(cur_route[j]);
                // console.log(cur_route[j]);
                //distance to baseline
                var distanceToLine = turf.pointToLineDistance(pt, baseLine, {units: 'kilometers'});
                // console.log(j,cur_route[j],distanceToLine);
                distance_point_toBaseLine.push(distanceToLine.toFixed(3));
            }
            distance_point_toBaseLine_multi.push(distance_point_toBaseLine);
          }
          console.log(distance_point_toBaseLine_multi);

          function func_routeSimilarity_calculateByPointToNearByPoint()
          {
            var distance_point_toBaseLine_multi = [];
            for (var i = 0; i < normalized_multiroutes.length-1; i++) {
                var base_route = normalized_multiroutes[i];
                var cur_route = normalized_multiroutes[i+1];
                // var baseLine = turf.lineString(base_route);
                // console.log(cur_route.join());
                var distance_point_toBaseLine = [];
                for (var j = 0; j < cur_route.length; j++) {
                    var pt = turf.point(cur_route[j]);
                    // console.log(cur_route[j]);
                    //distance to baseline
                    // var distanceToLine = turf.pointToLineDistance(pt, baseLine, {units: 'kilometers'});
                    var distanceToLine = func_distance_pointToRoute(pt, base_route);
                    // console.log(j,cur_route[j],distanceToLine);
                    distance_point_toBaseLine.push(distanceToLine.toFixed(3));
                }

                function func_distance_pointToRoute(param_point,param_route)
                {
                    var min_distance = 0;
                    var turf_point = turf.point(param_point);
                    for(var i_r=0;i_r<param_route.length;i_r++)
                    {
                        var to_point = turf.point(param_route[i_r]);
                        var dis =  turf.distance(turf_point, to_point, {units: 'kilometers'});
                        if(dis<min_distance)
                        {
                            min_distance = dis;
                        }
                    }
                    return min_distance;
                }

                distance_point_toBaseLine_multi.push(distance_point_toBaseLine);
            }
          }

          var data_x = [];
          for (var i = 0; i < pigeonNumbers.length-1; i++) {
            //   console.log(pigeonNumbers[i],release_time_list[i]);
              data_x.push(pigeonNumbers[i]+' '+release_time_list[i]+'   vs  '+pigeonNumbers[i+1]+' '+release_time_list[i+1]);
          }
          console.log(data_x);


        func_draw_boxplot();

        function func_draw_boxplot() {
            //set options
            var options = {
                series: [{
                    name: 'box',
                    type: 'boxPlot',
                    data: [
                    ]
                },],
                chart: {
                    type: 'boxPlot',
                    height: 350,
                },
                colors: ['#008FFB', '#FEB019'],
                title: {
                    text: '路徑相似度(km)',
                    align: 'middle'
                },
                tooltip: {
                    shared: false,
                    intersect: true
                },
                yaxis: {
                    // min: 0,
                    // max: 1000,
                    type: 'numeric',
                },
                // xaxis: {
                //     type: 'category',
                //     categories: data_x,
                // }
            }; 

            //sort distances
            var distance_point_toBaseLine_multi_sorted = [];
            for (var i = 0; i < distance_point_toBaseLine_multi.length; i++) {
                distance_point_toBaseLine_multi_sorted.push(distance_point_toBaseLine_multi[i].sort(function (a, b) { return a - b }));
            }
            console.log(distance_point_toBaseLine_multi_sorted);

            var median_list = [];
            for (var i = 0; i < distance_point_toBaseLine_multi_sorted.length; i++) {
                var data = distance_point_toBaseLine_multi_sorted[i];
                var min = data[0];
                var q1 = data[Math.floor(data.length / 4)];
                var median = data[Math.floor(data.length / 2)];
                median_list.push(median);
                var q3 = data[Math.floor(data.length * 3 / 4)];
                var max = data[data.length - 1];

                // options.series[0].data.push({ 'x': i, 'y': [min, q1, median, q3, max] });
                options.series[0].data.push({ 'x': data_x[i], 'y': [min, q1, median, q3, max] });
            }
            console.log(options.series[0].data);

            // var line_data = {type: 'line',data: median_list};
            // options.series[0].data.push(line_data);

            var canvas_multiRoutes_routeSimilarity = document.getElementById('canvas_multiRoutes_routeSimilarity');
            var chart = new ApexCharts(canvas_multiRoutes_routeSimilarity, options);

            chart.render();
        }
      }
    }

    
  </script>
</body>

</html>